<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web Pentesting on GET command and control</title>
    <link>https://GETC2.github.io/categories/web-pentesting/</link>
    <description>Recent content in Web Pentesting on GET command and control</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 11 Mar 2021 09:05:17 +0800</lastBuildDate><atom:link href="https://GETC2.github.io/categories/web-pentesting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WAF and Filter Bypass</title>
      <link>https://GETC2.github.io/post/waf-and-filter-bypass/</link>
      <pubDate>Thu, 11 Mar 2021 09:05:17 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/waf-and-filter-bypass/</guid>
      <description>WAF and Filter Bypass 针对Web攻击的防御主要分以下三种类型： 开发人员在应用内部自己写的filter 框架自带的filter inline security devices比如Web Application Firewall（WAF) 在进行渗透测试时，我们需要搞清楚目标有没有部署这些防御。否则可能会出现false negati</description>
    </item>
    
    <item>
      <title>Padding Oracle</title>
      <link>https://GETC2.github.io/post/padding-oracle/</link>
      <pubDate>Sun, 07 Mar 2021 21:09:29 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/padding-oracle/</guid>
      <description>Padding Oracle Attack 这里介绍如何借助块密码的padding来进行攻击并获取明文。首先介绍适用于这种攻击的一种padding。 PKSC#7 Padding 众所周知，块密码需要将明文分块然后加密。对于不满足分块大小的部分需要padding后才能加密。padding有不同的方法，有的直接在后面补\x</description>
    </item>
    
    <item>
      <title>CBC Bit Flipping</title>
      <link>https://GETC2.github.io/post/cbc-bit-flipping/</link>
      <pubDate>Sun, 07 Mar 2021 19:49:08 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/cbc-bit-flipping/</guid>
      <description>CBC Bit Flipping 这里介绍一下如何针对CBC模式的块密码进行攻击。首先还是回顾一下该模式下加密的过程： 如上所示，明文首先分块，然后和IV或者前一个加密分块异或，最后经由key加密。 针对这种模式的块密码，我们可以这样处理： 如上图所示，如果我们只有密文和IV，那么我们可以</description>
    </item>
    
    <item>
      <title>Block Cipher ECB Shuffling</title>
      <link>https://GETC2.github.io/post/block-cipher-ecb-shuffling/</link>
      <pubDate>Sun, 07 Mar 2021 16:25:29 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/block-cipher-ecb-shuffling/</guid>
      <description>Block Cipher ECB Shuffling 这里我们介绍针对块密码的ECB shuffling攻击。首先还是回顾一下块密码的Electronic Code Book(ECB)模式： 可以看到，明文被分块，每个分块被分别加密。分块大小根据选择的算法不同而不同。比如DES,3DES为8；而AES为16字节。由</description>
    </item>
    
    <item>
      <title>Steam Cipher IV Collision</title>
      <link>https://GETC2.github.io/post/steam-cipher-iv-collision/</link>
      <pubDate>Sun, 07 Mar 2021 15:38:56 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/steam-cipher-iv-collision/</guid>
      <description>Stream Cipher IV Collision 首先用一张图表示流密码的加密解密过程： 流密码的特点是： 密文和明文的长度相同 改变明文的一部分，密文的相应部分也会改变，其余部分不变 密文长度没有必要是8字节或者16字节的整数倍，这是和块密码的区别 需要注意的是，如果使用流密码加密，那么需要在加密不同信息</description>
    </item>
    
    <item>
      <title>Attacking Encryption Key</title>
      <link>https://GETC2.github.io/post/attacking-encryption-key/</link>
      <pubDate>Sun, 07 Mar 2021 14:31:11 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/attacking-encryption-key/</guid>
      <description>Attacking Encryption key 我们经常可以看到加密被应用在Web的以下方面： Session tokens 密码哈希 加密CAPTCHAs 服务器文件名 Cookie Hidden fields 数据库数据 在针对Web进行渗透时，我们可能需要针对这些加密进行攻击。比如如果服务器存在LFI漏洞，但是由于文件名进行了加密或者哈希处理，那么我们就需要搞清</description>
    </item>
    
    <item>
      <title>Sql Injection</title>
      <link>https://GETC2.github.io/post/sql-injection/</link>
      <pubDate>Sun, 07 Mar 2021 08:43:04 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/sql-injection/</guid>
      <description>SQL Injection 针对SQL Injection，我们可以按照以下的步骤处理： 寻找注入点 在这里不赘述如何判断注入点。最简单的情况是当输入单引号或者双引号，数据库的语法错误直接回显，然后就可以确定这是注入点。在后端不返回任何响应的情况下，可以通过猜测查询语句context来</description>
    </item>
    
    <item>
      <title>Type Inference in PHP</title>
      <link>https://GETC2.github.io/post/type-inference-in-php/</link>
      <pubDate>Fri, 05 Mar 2021 18:37:00 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/type-inference-in-php/</guid>
      <description>Type Inference in PHP PHP是动态类型语言。当定义变量时，我们不需要指定变量类型，PHP会根据赋值推断变量的类型。另外，在进行数学运算或loose comparison的时候，如果操作数类型不一致或者不与运算符相符，那么PHP会自动进行类型转换。它会根据操作数和操作符来推</description>
    </item>
    
    <item>
      <title>Templet Injection</title>
      <link>https://GETC2.github.io/post/templet-injection/</link>
      <pubDate>Thu, 04 Mar 2021 19:23:27 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/templet-injection/</guid>
      <description>Templet Injection 关于什么是模板注入，这里就不多说了。主要记录一下模板注入漏洞的利用流程。 发现模板注入漏洞 不同框架利用的模板引擎不同，所使用的模板语言也就不同。但是发现漏洞的方法是一致的。一般都是通过再用户控制的输入中插入模板语言定义的逻辑操作，比如数学计算： @(2*2) //Razor ${2*2} //Freemarker {{2*2}}</description>
    </item>
    
    <item>
      <title>File Inclusion</title>
      <link>https://GETC2.github.io/post/file-inclusion/</link>
      <pubDate>Mon, 01 Mar 2021 10:23:59 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/file-inclusion/</guid>
      <description>文件包含 要想高效地利用文件包含漏洞，我们可以遵循以下的方法： 搞清楚该漏洞针对文件路径的限制。比如 用户控制的文件名是否有前缀和后缀 是否允许根目录之外的文件路径 是否允许绝对路径或者URL 利用漏洞获取本地文件。 特定于操作系统的文件，比如Linux的/etc/pa</description>
    </item>
    
    <item>
      <title>AFL Fuzzing</title>
      <link>https://GETC2.github.io/post/afl-fuzzing/</link>
      <pubDate>Sat, 20 Feb 2021 09:38:43 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/afl-fuzzing/</guid>
      <description>American Fuzzy Lop (AFL) 之前介绍过Sulley这个框架，马上要介绍的AFL与Sulley有两个不同： Sulley用来测试使用协议的服务端应用；而AFL用来测试本地接受输入的应用 AFL具有一定的intelligence。它可以记录特定输入和与之对应的应用执行路径。根据这些记</description>
    </item>
    
    <item>
      <title>XSS</title>
      <link>https://GETC2.github.io/post/xss/</link>
      <pubDate>Wed, 03 Feb 2021 13:59:10 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/xss/</guid>
      <description>Cross Site Scripting XSS漏洞大概分为三种： 反射型XSS 存储型XSS DOM XSS 其中存储型的漏洞的注入点一般是博客的评论，社交网站的各种个人介绍或者动态。这些注入是直接通过HTTP来和目标服务交互的。但是除了这种注入外，还有一种称为Out-of-band存储型XSS。 具体来说就</description>
    </item>
    
    <item>
      <title>Username Harvesting</title>
      <link>https://GETC2.github.io/post/username-harvesting/</link>
      <pubDate>Mon, 01 Feb 2021 18:48:32 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/username-harvesting/</guid>
      <description>在针对Web进行渗透测试并发现用户登录入口的时候，下一步就是字典或者爆破。但是为了更有效率，我们首先需要有效的用户名列表。 我们可以在收集信息时就注意有关用户名的信息；另一种方法就是依靠登录界面面对有效用户名和无效用户名的不一致性来推测。这又细分为两种方法：</description>
    </item>
    
    <item>
      <title>Virtual Host Discovery</title>
      <link>https://GETC2.github.io/post/virtual-host-discovery/</link>
      <pubDate>Sat, 30 Jan 2021 18:34:55 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/virtual-host-discovery/</guid>
      <description>之前说过在针对Web进行渗透测试时，需要知道目标的Host Name。因为一个IP可能有多个Host，不知道对应的域名，就无法访问网站，那么渗透测试也就无从说起。 针对这个问题，之前通过DNS试图寻找目标的隐藏Host。其实我们还可以通过HTTPS证书来查找目</description>
    </item>
    
    <item>
      <title>DNS Harvesting</title>
      <link>https://GETC2.github.io/post/dns-harvesting/</link>
      <pubDate>Sat, 30 Jan 2021 15:08:37 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/dns-harvesting/</guid>
      <description>DNS Harvesting 在针对Web进行渗透时，我们需要尽可能地掌握目标的所有可访问域名。有的域名并没有被目标的其他的页面reference到的情况下，我们可以利用DNS来获取隐藏域名。 通过DNS的话一般有以下几个方法： DNS zone transfer DNS brute force DNS reverse lookup 一般来说DNS zone transfer的情况</description>
    </item>
    
    <item>
      <title>Hydra</title>
      <link>https://GETC2.github.io/post/hydra/</link>
      <pubDate>Thu, 28 Jan 2021 13:56:42 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/hydra/</guid>
      <description>利用Hydra进行password guessing 在对密码进行猜测时，Hydra很灵活。它可以针对单个或者多个目标进行密码猜测，同时支持单个用户，密码或者用户列表，密码列表来进行密码猜测。 完善字典 由于目标可能存在lockout，我们需要尽可能完善字典，删除不必要的密码。</description>
    </item>
    
    <item>
      <title>Nmap</title>
      <link>https://GETC2.github.io/post/nmap/</link>
      <pubDate>Thu, 21 Jan 2021 12:42:25 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/nmap/</guid>
      <description>Nmap完整使用流程 Host discovery 第一步是发现上线机器，由于nmap默认端口扫描之前会进行机器上线确定，如果单纯为了扫描机器而不需要扫描端口的话，可以直接指定·-sP选项： 由于指定了--packet-trace选项，nmap会显示具体的发包。可以看出，由于目标地址块</description>
    </item>
    
    <item>
      <title>Recon-ng</title>
      <link>https://GETC2.github.io/post/recon-ng/</link>
      <pubDate>Mon, 18 Jan 2021 21:00:11 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/recon-ng/</guid>
      <description>利用Recon-ng收集信息 Recon-ng是一个用来收集目标的框架。通过这篇博客来记录Recon-ng的基本使用。 实验设置 目标的DNS服务器地址是10.10.10.60. 利用已有的目标IP地址块来进行反向DNS查询确定域名。 利用DNS cache snooping来</description>
    </item>
    
    <item>
      <title>Metadata Treasure Hunt</title>
      <link>https://GETC2.github.io/post/metadata-threasure-hunt/</link>
      <pubDate>Mon, 18 Jan 2021 15:34:26 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/metadata-threasure-hunt/</guid>
      <description>文件元数据收集 （Recon） 通过这个博客来展示在recon的过程中，如何从文件元数据中获得有用的信息。 实验设置 现在我们手头上有三个文件： WidgetStatisticalAnalysis.xls WidgetStatisticalWhitepaper.doc WidgetStatisticalWhitepaper.pdf 目标是利用exiftool和strings来收集关于目标的信息。 Exiftool 首先用exiftool来看看doc文件有什么元数</description>
    </item>
    
    <item>
      <title>Accessing Internal Websites with Host Head Injection</title>
      <link>https://GETC2.github.io/post/accessing-internal-websites/</link>
      <pubDate>Sun, 08 Nov 2020 14:39:50 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/accessing-internal-websites/</guid>
      <description>有的公司会让同一个服务器伺服外部网站和内部网站。这样的服务器同时具有公网IP和内网IP。如果光是查看DNS record的话无法知道外部网站和内部网站位于同一个服务器；而且有的内部域名并没有公共的DNS record。但是只要知道内部域名对应的IP地址或者域名</description>
    </item>
    
    <item>
      <title>Bypass Authentication with Host Header Injection</title>
      <link>https://GETC2.github.io/post/access-restricted-func/</link>
      <pubDate>Sun, 08 Nov 2020 10:55:47 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/access-restricted-func/</guid>
      <description>有的应用通过Host头部来实现用户认证，这种时候可以通过操作Host头部来绕过认证。 这种情况比较简单，直接通过lab来说明比较直观。 lab lab描述 访问管理员页面并删除用户carlos的帐号。 首先需要搞清楚管理员页面是什么。我们可以通过burpsuite来对应</description>
    </item>
    
    <item>
      <title>Web Cache Poisoning</title>
      <link>https://GETC2.github.io/post/web-cache-poison/</link>
      <pubDate>Sun, 08 Nov 2020 09:11:56 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/web-cache-poison/</guid>
      <description>这一篇博客主要记录如何利用Host头部注入以及Web cache poisoning来实现客户端攻击。 有的时候我们会发现应用容易受到Host头部攻击，应用会将攻击者注入Host头部的payload返回给用户。XSS和Host头部注入有点相似，XSS是攻击者构造链接诱使</description>
    </item>
    
    <item>
      <title>Password Reset Poisoning</title>
      <link>https://GETC2.github.io/post/password-reset-poisoning/</link>
      <pubDate>Sat, 07 Nov 2020 10:28:48 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/password-reset-poisoning/</guid>
      <description>上一篇博客讲的是Host头部注入攻击。这种攻击可以用来实现多种其他种类的攻击。其中一种就是password reset poisoning . 下面通过两个lab来具体看看这种攻击是如何重置其他用户的密码的。 一般的网站都有密码重置功能。其中一种实现方法是提供需要重置密码的用户名，然后网站</description>
    </item>
    
    <item>
      <title>Host头部攻击</title>
      <link>https://GETC2.github.io/post/host-head-attack/</link>
      <pubDate>Thu, 05 Nov 2020 16:02:41 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/host-head-attack/</guid>
      <description>Host头部由来 HTTP/1.1强制要求Host请求头。在以下几种情况下，没有Host头部无法获得请求的资源。 在服务器同时伺服多个域名的时候，服务器需要知道请求所指向的具体域名。 客户端与多个后端之间存在中间节点，比如负载均衡器和反向代理。此时中间节点需要知</description>
    </item>
    
  </channel>
</rss>
