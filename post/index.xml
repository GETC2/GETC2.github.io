<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on GET command and control</title>
    <link>https://GETC2.github.io/post/</link>
    <description>Recent content in Posts on GET command and control</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 18 Jan 2021 15:34:26 +0800</lastBuildDate><atom:link href="https://GETC2.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Metadata Treasure Hunt</title>
      <link>https://GETC2.github.io/post/metadata-threasure-hunt/</link>
      <pubDate>Mon, 18 Jan 2021 15:34:26 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/metadata-threasure-hunt/</guid>
      <description>文件元数据收集 （Recon） 通过这个博客来展示在recon的过程中，如何从文件元数据中获得有用的信息。 实验设置 现在我们手头上有三个文件： WidgetStatisticalAnalysis.xls WidgetStatisticalWhitepaper.doc WidgetStatisticalWhitepaper.pdf 目标是利用exiftool和strings来收集关于目标的信息。 Exiftool 首先用exiftool来看看doc文件有什么元数</description>
    </item>
    
    <item>
      <title>Egress Analysis</title>
      <link>https://GETC2.github.io/post/egress-analysis/</link>
      <pubDate>Wed, 30 Dec 2020 09:52:56 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/egress-analysis/</guid>
      <description>简介 作为红队，我们需要知道蓝队是如何防守的，这样我们才能更好地进攻。我们以Data Exfiltration为例，来研究蓝队是如何检测和阻止的。 实验环境 如上图所示，红队需要把sensitive_data.csv上传到攻击者的机器上；而蓝队需要检测并阻止红队的</description>
    </item>
    
    <item>
      <title>Accessing Internal Websites</title>
      <link>https://GETC2.github.io/post/accessing-internal-websites/</link>
      <pubDate>Sun, 08 Nov 2020 14:39:50 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/accessing-internal-websites/</guid>
      <description>利用Host头部注入访问内网 有的公司会让同一个服务器伺服外部网站和内部网站。这样的服务器同时具有公网IP和内网IP。如果光是查看DNS record的话无法知道外部网站和内部网站位于同一个服务器；而且有的内部域名并没有公共的DNS record。但是只要知道内</description>
    </item>
    
    <item>
      <title>Access Restricted Func</title>
      <link>https://GETC2.github.io/post/access-restricted-func/</link>
      <pubDate>Sun, 08 Nov 2020 10:55:47 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/access-restricted-func/</guid>
      <description>通过Host头部注入绕过认证 有的应用通过Host头部来实现用户认证，这种时候可以通过操作Host头部来绕过认证。 这种情况比较简单，直接通过lab来说明比较直观。 lab lab描述 访问管理员页面并删除用户carlos的帐号。 首先需要搞清楚管理员页面是什么。我们可以</description>
    </item>
    
    <item>
      <title>Web Cache Poisoning</title>
      <link>https://GETC2.github.io/post/web-cache-poison/</link>
      <pubDate>Sun, 08 Nov 2020 09:11:56 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/web-cache-poison/</guid>
      <description>Web Cache Poisoning 这一篇博客主要记录如何利用Host头部注入以及Web cache poisoning来实现客户端攻击。 有的时候我们会发现应用容易受到Host头部攻击，应用会将攻击者注入Host头部的payload返回给用户。XSS和Host头部注入有点相似，XSS是攻击者构造链</description>
    </item>
    
    <item>
      <title>Password Reset Poisoning</title>
      <link>https://GETC2.github.io/post/password-reset-poisoning/</link>
      <pubDate>Sat, 07 Nov 2020 10:28:48 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/password-reset-poisoning/</guid>
      <description>Host头部注入攻击 上一篇博客讲的是Host头部注入攻击。这种攻击可以用来实现多种其他种类的攻击。其中一种就是password reset poisoning . 下面通过两个lab来具体看看这种攻击是如何重置其他用户的密码的。 Password Reset Poisoning 一般的网站都有密码重置功能。其中一种实现方法是提供需要</description>
    </item>
    
    <item>
      <title>Host头部攻击</title>
      <link>https://GETC2.github.io/post/host-head-attack/</link>
      <pubDate>Thu, 05 Nov 2020 16:02:41 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/host-head-attack/</guid>
      <description>Host头部由来 HTTP/1.1强制要求Host请求头。在以下几种情况下，没有Host头部无法获得请求的资源。 在服务器同时伺服多个域名的时候，服务器需要知道请求所指向的具体域名。 客户端与多个后端之间存在中间节点，比如负载均衡器和反向代理。此时中间节点需要知</description>
    </item>
    
  </channel>
</rss>
