<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on GET command and control</title>
    <link>https://GETC2.github.io/post/</link>
    <description>Recent content in Posts on GET command and control</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 28 Jan 2021 15:54:52 +0800</lastBuildDate><atom:link href="https://GETC2.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sniff Ntlm</title>
      <link>https://GETC2.github.io/post/sniff-ntlm/</link>
      <pubDate>Thu, 28 Jan 2021 15:54:52 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/sniff-ntlm/</guid>
      <description>嗅探NTLM协议并破解密码 除了dump目标机器的hash之外，还可以直接嗅探NTLM协议然后破解密码。 下面介绍一下基本的步骤和时用到的工具。 1. 嗅探NTLM协议 首先我们使用tcpdump来嗅探针对端口445的访问： sudo tcpdump -nv -s0 port 445 -w /tmp/winauth.pcap 参数-s0是为了指示tcpd</description>
    </item>
    
    <item>
      <title>Msf Pivot</title>
      <link>https://GETC2.github.io/post/msf-pivot/</link>
      <pubDate>Thu, 28 Jan 2021 15:13:59 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/msf-pivot/</guid>
      <description>与metasploit有关的pivoting方法总结 1. metasploit内置的端口转发 首先是最简单的端口转发，命令如下所示： portfwd add -l local_port_num -r ip_addr -p remote_port_num 在meterpreter内执行此命令后，会在本地端口和远程IP很远程端口之间转发。 2. metasploit内置的ro</description>
    </item>
    
    <item>
      <title>Dump the Hash</title>
      <link>https://GETC2.github.io/post/dump-the-hash/</link>
      <pubDate>Thu, 28 Jan 2021 14:41:09 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/dump-the-hash/</guid>
      <description>利用meterpreter获取目标机器的hash 在后渗透的阶段，很重要的一项任务就是获取目标机器上的hash，当然不论是windows还是linux都需要有相应的权限才有可能获取到hash。 在这里，我们演示如何通过meterpreter的后渗透模块来获取h</description>
    </item>
    
    <item>
      <title>Hydra</title>
      <link>https://GETC2.github.io/post/hydra/</link>
      <pubDate>Thu, 28 Jan 2021 13:56:42 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/hydra/</guid>
      <description>利用Hydra进行password guessing 在对密码进行猜测时，Hydra很灵活。它可以针对单个或者多个目标进行密码猜测，同时支持单个用户，密码或者用户列表，密码列表来进行密码猜测。 完善字典 由于目标可能存在lockout，我们需要尽可能完善字典，删除不必要的密码。</description>
    </item>
    
    <item>
      <title>Empire</title>
      <link>https://GETC2.github.io/post/empire/</link>
      <pubDate>Wed, 27 Jan 2021 08:22:03 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/empire/</guid>
      <description>Empire的基本使用流程 Empire是用于后渗透阶段的框架，里面整合了用于各种后渗透阶段活动的powershell脚本。这里记录一下empire的基本使用流程。 实验环境 实验由两台主机组成，一个是攻击者主机，另一台是目标主机。 实验步骤 1 启动Empire 首先</description>
    </item>
    
    <item>
      <title>Netcat port forward</title>
      <link>https://GETC2.github.io/post/netcat_port_forward/</link>
      <pubDate>Wed, 27 Jan 2021 07:58:38 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/netcat_port_forward/</guid>
      <description>利用netcat实现端口转发 实验环境 现有两台主机，一台是攻击者主机（windows），另一台是目标主机（Linux）。目标是通过攻击者主机成功登录目标主机ssh服务。 实验步骤 首先利用Putty登录目标主机： 可以看到成功登录ssh服务。 然后我们在目标主机的防</description>
    </item>
    
    <item>
      <title>Veil</title>
      <link>https://GETC2.github.io/post/veil/</link>
      <pubDate>Tue, 26 Jan 2021 18:32:29 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/veil/</guid>
      <description>Veil的一般使用流程 veil框架主要用来生成payload并对payload进行免杀。下面我们来看一下veil的基本使用步骤。 veil主要由两个工具组成，我们主要关注如何通过Evasion来对payload免杀。可以看到，初始界面会提示veil支持的命令</description>
    </item>
    
    <item>
      <title>Nmap</title>
      <link>https://GETC2.github.io/post/nmap/</link>
      <pubDate>Thu, 21 Jan 2021 12:42:25 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/nmap/</guid>
      <description>Nmap完整使用流程 Host discovery 第一步是发现上线机器，由于nmap默认端口扫描之前会进行机器上线确定，如果单纯为了扫描机器而不需要扫描端口的话，可以直接指定·-sP选项： 由于指定了--packet-trace选项，nmap会显示具体的发包。可以看出，由于目标地址块</description>
    </item>
    
    <item>
      <title>Recon-ng</title>
      <link>https://GETC2.github.io/post/recon-ng/</link>
      <pubDate>Mon, 18 Jan 2021 21:00:11 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/recon-ng/</guid>
      <description>利用Recon-ng收集信息 Recon-ng是一个用来收集目标的框架。通过这篇博客来记录Recon-ng的基本使用。 实验设置 目标的DNS服务器地址是10.10.10.60. 利用已有的目标IP地址块来进行反向DNS查询确定域名。 利用DNS cache snooping来</description>
    </item>
    
    <item>
      <title>Metadata Treasure Hunt</title>
      <link>https://GETC2.github.io/post/metadata-threasure-hunt/</link>
      <pubDate>Mon, 18 Jan 2021 15:34:26 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/metadata-threasure-hunt/</guid>
      <description>文件元数据收集 （Recon） 通过这个博客来展示在recon的过程中，如何从文件元数据中获得有用的信息。 实验设置 现在我们手头上有三个文件： WidgetStatisticalAnalysis.xls WidgetStatisticalWhitepaper.doc WidgetStatisticalWhitepaper.pdf 目标是利用exiftool和strings来收集关于目标的信息。 Exiftool 首先用exiftool来看看doc文件有什么元数</description>
    </item>
    
    <item>
      <title>Egress Analysis</title>
      <link>https://GETC2.github.io/post/egress-analysis/</link>
      <pubDate>Wed, 30 Dec 2020 09:52:56 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/egress-analysis/</guid>
      <description>简介 作为红队，我们需要知道蓝队是如何防守的，这样我们才能更好地进攻。我们以Data Exfiltration为例，来研究蓝队是如何检测和阻止的。 实验环境 如上图所示，红队需要把sensitive_data.csv上传到攻击者的机器上；而蓝队需要检测并阻止红队的</description>
    </item>
    
    <item>
      <title>Accessing Internal Websites</title>
      <link>https://GETC2.github.io/post/accessing-internal-websites/</link>
      <pubDate>Sun, 08 Nov 2020 14:39:50 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/accessing-internal-websites/</guid>
      <description>利用Host头部注入访问内网 有的公司会让同一个服务器伺服外部网站和内部网站。这样的服务器同时具有公网IP和内网IP。如果光是查看DNS record的话无法知道外部网站和内部网站位于同一个服务器；而且有的内部域名并没有公共的DNS record。但是只要知道内</description>
    </item>
    
    <item>
      <title>Access Restricted Func</title>
      <link>https://GETC2.github.io/post/access-restricted-func/</link>
      <pubDate>Sun, 08 Nov 2020 10:55:47 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/access-restricted-func/</guid>
      <description>通过Host头部注入绕过认证 有的应用通过Host头部来实现用户认证，这种时候可以通过操作Host头部来绕过认证。 这种情况比较简单，直接通过lab来说明比较直观。 lab lab描述 访问管理员页面并删除用户carlos的帐号。 首先需要搞清楚管理员页面是什么。我们可以</description>
    </item>
    
    <item>
      <title>Web Cache Poisoning</title>
      <link>https://GETC2.github.io/post/web-cache-poison/</link>
      <pubDate>Sun, 08 Nov 2020 09:11:56 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/web-cache-poison/</guid>
      <description>Web Cache Poisoning 这一篇博客主要记录如何利用Host头部注入以及Web cache poisoning来实现客户端攻击。 有的时候我们会发现应用容易受到Host头部攻击，应用会将攻击者注入Host头部的payload返回给用户。XSS和Host头部注入有点相似，XSS是攻击者构造链</description>
    </item>
    
    <item>
      <title>Password Reset Poisoning</title>
      <link>https://GETC2.github.io/post/password-reset-poisoning/</link>
      <pubDate>Sat, 07 Nov 2020 10:28:48 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/password-reset-poisoning/</guid>
      <description>Host头部注入攻击 上一篇博客讲的是Host头部注入攻击。这种攻击可以用来实现多种其他种类的攻击。其中一种就是password reset poisoning . 下面通过两个lab来具体看看这种攻击是如何重置其他用户的密码的。 Password Reset Poisoning 一般的网站都有密码重置功能。其中一种实现方法是提供需要</description>
    </item>
    
    <item>
      <title>Host头部攻击</title>
      <link>https://GETC2.github.io/post/host-head-attack/</link>
      <pubDate>Thu, 05 Nov 2020 16:02:41 +0800</pubDate>
      
      <guid>https://GETC2.github.io/post/host-head-attack/</guid>
      <description>Host头部由来 HTTP/1.1强制要求Host请求头。在以下几种情况下，没有Host头部无法获得请求的资源。 在服务器同时伺服多个域名的时候，服务器需要知道请求所指向的具体域名。 客户端与多个后端之间存在中间节点，比如负载均衡器和反向代理。此时中间节点需要知</description>
    </item>
    
  </channel>
</rss>
